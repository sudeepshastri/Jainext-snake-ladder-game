<script>
        // Game Configuration
        const BOARD_SIZE = 100;
        const SNAKES = { 16: 6, 47: 26, 49: 11, 56: 53, 62: 19, 64: 60, 87: 24, 93: 63, 95: 55, 99: 18 };
        const LADDERS = { 1: 38, 4: 14, 9: 31, 21: 42, 28: 84, 36: 44, 51: 67, 71: 91, 80: 96 };
        
        const DEFAULT_ASSETS = {
            logo: 'assets/logo.png',
            questions: 'assets/questions.csv',
            sounds: {
                timerTickSound: 'assets/Timer_Tick.mp3',
                diceRollSound: 'assets/Dice_Roll.mp3',
                correctSound: 'assets/Correct_Answer.mp3',
                wrongSound: 'assets/Wrong_Answer.mp3',
                moveSound: 'assets/Player_Move.mp3',
                snakeSound: 'assets/Snake.mp3',
                ladderSound: 'assets/Ladder.mp3',
                winSound: 'assets/Wrong_Answer.mp3'
            }
        };

        // Game State
        let gameState = {};
        let history = [];
        let historyIndex = -1;
        const MAX_HISTORY = 10;
        const MAX_STUCK_TURNS = 4;

        const DEFAULT_QUESTIONS_RAW_CSV = `question,option1,option2,option3,option4,answer,level,group
"What is the capital of France, a country in Europe?","Berlin","Madrid","Paris","Rome",3,easy,geography
"What is 8 x 7?","54","56","64","68",2,medium,math
"Who wrote 'Romeo and Juliet'?","Charles Dickens","Jane Austen","William Shakespeare","Mark Twain",3,hard,literature`;

        function initializeGameState() {
             gameState = {
                players: [],
                currentPlayerIndex: 0,
                gameStarted: false,
                masterQuestions: [],
                availableQuestions: [],
                usedQuestions: [],
                allQuestionGroups: [],
                selectedQuestionGroup: null,
                csvUploaded: false,
                logoUploaded: false,
                soundsUploaded: {},
                timerDuration: 15,
                winners: [],
                soundEnabled: true,
                volume: 0.5,
                currentQuestion: null,
                selectedOption: -1,
                questionTimer: null,
                isSubmitting: false
            };
        }

        document.addEventListener('DOMContentLoaded', function() {
            initializeGameState();
            setupNumberOfPlayers();
            createBoard();
            setupVolumeControl();
            setupGameNameInput();
            updateHistoryButtons();
            updateHeaderButtons();
            
            document.addEventListener('keydown', handleKeyboardShortcuts);

            window.addEventListener('resize', () => {
                if (gameState.gameStarted) {
                    drawSnakesAndLadders();
                }
            });
        });
        
        function updateHeaderButtons() {
            const gameIsOver = isGameOver();
            const gameIsInProgress = gameState.gameStarted && !gameIsOver;

            document.getElementById('headerStartBtn').disabled = gameState.gameStarted;
            document.getElementById('headerEndGameBtn').disabled = !gameIsInProgress;
        }

        function handleKeyboardShortcuts(event) {
            const activeElement = document.activeElement;
            if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'SELECT')) {
                return;
            }

            if (event.key.toLowerCase() === 'pagedown') {
                event.preventDefault();
                document.getElementById('rollButton').click();
                return;
            }

            if (event.ctrlKey) {
                if (event.key.toLowerCase() === 'z') {
                    event.preventDefault();
                    document.getElementById('undoButton').click();
                }
                if (event.key.toLowerCase() === 'y') {
                    event.preventDefault();
                    document.getElementById('redoButton').click();
                }
            } else if (event.altKey) {
                event.preventDefault();
                switch (event.key.toLowerCase()) {
                    case 'd':
                        document.getElementById('rollButton').click();
                        break;
                    case 's':
                        if (document.getElementById('questionPopup').classList.contains('active')) {
                            document.getElementById('submitButton').click();
                        }
                        break;
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                        if (document.getElementById('questionPopup').classList.contains('active') && !gameState.isSubmitting) {
                            const optionIndex = parseInt(event.key) - 1;
                            const options = document.querySelectorAll('#optionsContainer .option');
                            if (options[optionIndex]) {
                                selectOption(optionIndex, options[optionIndex]);
                                submitAnswer();
                            }
                        }
                        break;
                }
            }
        }

        function deepClone(obj) {
            return JSON.parse(JSON.stringify(obj));
        }

        function saveStateToHistory() {
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }
            history.push(deepClone(gameState));
            if (history.length > MAX_HISTORY) {
                history.shift();
            }
            historyIndex = history.length - 1;
            updateHistoryButtons();
        }

        function loadStateFromHistory(index) {
            if (index >= 0 && index < history.length) {
                gameState = deepClone(history[index]);
                historyIndex = index;
                updateAllUI();
                updateHistoryButtons();
            }
        }
        
        function undoStep() {
            if (historyIndex > 0) {
                loadStateFromHistory(historyIndex - 1);
            }
        }

        function redoStep() {
            if (historyIndex < history.length - 1) {
                loadStateFromHistory(historyIndex + 1);
            }
        }

        function updateHistoryButtons() {
            document.getElementById('undoButton').disabled = historyIndex <= 0;
            document.getElementById('redoButton').disabled = historyIndex >= history.length - 1;
        }

        function updateAllUI() {
            updateHeaderButtons();
            updatePlayersDisplay();
            updateCurrentPlayerDisplay();
            updateGameBoard();
            setTimeout(drawSnakesAndLadders, 50);
            
            const gameIsOver = isGameOver();
            const rollButtonsDisabled = gameIsOver || !gameState.gameStarted;
            document.getElementById('rollButton').disabled = rollButtonsDisabled;
            document.getElementById('skipTurnButton').disabled = rollButtonsDisabled;
            document.getElementById('winnersSection').style.display = gameIsOver ? 'block' : 'none';
        }

        function isGameOver() {
            if (!gameState.gameStarted) return false;
            const nonWinnersCount = gameState.players.length - gameState.winners.length;
            const maxWinners = Math.min(3, gameState.players.length > 1 ? gameState.players.length - 1 : 1);
            return (gameState.winners.length >= maxWinners && maxWinners > 0) || (nonWinnersCount <= 1 && gameState.players.length > 1);
        }
        
        function createBoard() {
            const board = document.getElementById('gameBoard');
            board.innerHTML = '<svg id="svgLayer" class="svg-layer"></svg>';
            let cells = [];
            for (let i = 1; i <= BOARD_SIZE; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.id = `cell-${i}`;
                cell.innerHTML = `<span class="cell-number">${i}</span>`;
                if (SNAKES[i]) {
                    cell.classList.add('snake-start');
                    cell.innerHTML += `<div class="emoji">üêç</div>`;
                } else if (LADDERS[i]) {
                    cell.classList.add('ladder-start');
                    cell.innerHTML += `<div class="emoji">ü™ú</div>`;
                }
                cells.push(cell);
            }
            for (let row = 9; row >= 0; row--) {
                let rowCells = cells.slice(row * 10, (row + 1) * 10);
                if (row % 2 !== 0) rowCells.reverse();
                rowCells.forEach(cell => board.appendChild(cell));
            }
        }

        function getCellCenter(cellNumber) {
            const cell = document.getElementById(`cell-${cellNumber}`);
            if (!cell) return { x: 0, y: 0 };
            const board = document.getElementById('gameBoard');
            const boardRect = board.getBoundingClientRect();
            const cellRect = cell.getBoundingClientRect();
            return {
                x: cellRect.left - boardRect.left + cellRect.width / 2,
                y: cellRect.top - boardRect.top + cellRect.height / 2
            };
        }

        function drawSnakesAndLadders() {
            const svg = document.getElementById('svgLayer');
            svg.innerHTML = '';
            for (const start in LADDERS) {
                const end = LADDERS[start];
                const p1 = getCellCenter(start);
                const p2 = getCellCenter(end);
                const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                const ladderWidth = 8;
                const p1_l = { x: p1.x - ladderWidth * Math.sin(angle), y: p1.y + ladderWidth * Math.cos(angle) };
                const p1_r = { x: p1.x + ladderWidth * Math.sin(angle), y: p1.y - ladderWidth * Math.cos(angle) };
                const p2_l = { x: p2.x - ladderWidth * Math.sin(angle), y: p2.y + ladderWidth * Math.cos(angle) };
                const p2_r = { x: p2.x + ladderWidth * Math.sin(angle), y: p2.y - ladderWidth * Math.cos(angle) };
                svg.innerHTML += `<line x1="${p1_l.x}" y1="${p1_l.y}" x2="${p2_l.x}" y2="${p2_l.y}" class="ladder-side" />`;
                svg.innerHTML += `<line x1="${p1_r.x}" y1="${p1_r.y}" x2="${p2_r.x}" y2="${p2_r.y}" class="ladder-side" />`;
                const numRungs = Math.floor(Math.sqrt((p2.x - p1.x)**2 + (p2.y - p1.y)**2) / 20);
                for (let i = 1; i <= numRungs; i++) {
                    const rung_p1 = { x: p1_l.x + (p2_l.x - p1_l.x) * i / (numRungs + 1), y: p1_l.y + (p2_l.y - p1_l.y) * i / (numRungs + 1) };
                    const rung_p2 = { x: p1_r.x + (p2_r.x - p1_r.x) * i / (numRungs + 1), y: p1_r.y + (p2_r.y - p1_r.y) * i / (numRungs + 1) };
                    svg.innerHTML += `<line x1="${rung_p1.x}" y1="${rung_p1.y}" x2="${rung_p2.x}" y2="${rung_p2.y}" class="ladder-rung" />`;
                }
            }
            for (const start in SNAKES) {
                const end = SNAKES[start];
                const p1 = getCellCenter(start);
                const p2 = getCellCenter(end);
                const mid = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
                const dist = Math.sqrt((p2.x - p1.x)**2 + (p2.y - p1.y)**2);
                const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                const offset = dist / 4;
                const control = { x: mid.x + offset * Math.sin(angle), y: mid.y - offset * Math.cos(angle) };
                
                const pathData = `M ${p1.x} ${p1.y} Q ${control.x} ${control.y} ${p2.x} ${p2.y}`;
                svg.innerHTML += `<path d="${pathData}" class="snake-outline" />`;
                svg.innerHTML += `<path d="${pathData}" class="snake-body" />`;
            }
        }
        
        function setupNumberOfPlayers() {
            document.getElementById('numPlayers').addEventListener('change', (e) => createPlayerNameInputs(parseInt(e.target.value)));
            createPlayerNameInputs(4);
        }

        function createPlayerNameInputs(num) {
            const container = document.getElementById('playerNames');
            container.innerHTML = '';
            for (let i = 1; i <= num; i++) {
                container.innerHTML += `<div class="input-group"><label for="player${i}Name">üë§ Player ${i} Name:</label><input type="text" id="player${i}Name" placeholder="Player ${i}" value="Player ${i}"></div>`;
            }
        }
        
        function setupVolumeControl() {
            document.getElementById('volumeSlider').addEventListener('input', function() {
                gameState.volume = this.value / 100;
                document.getElementById('volumeIcon').textContent = gameState.volume > 0 ? 'üîä' : 'üîá';
                updateSoundVolume();
            });
        }
        
        function handleLogoUpload(event) {
            const file = event.target.files[0];
            const label = document.getElementById('logoLabel');
            if (file && file.type.startsWith("image/")) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const imgSrc = e.target.result;
                    const headerImg = document.getElementById('gameLogoImg');
                    headerImg.src = imgSrc;
                    headerImg.style.display = 'block';
                    headerImg.parentElement.querySelector('span').style.display = 'none';
                    const boardImg = document.getElementById('boardLogoImg');
                    boardImg.src = imgSrc;
                    boardImg.style.display = 'block';
                    gameState.logoUploaded = true;
                    label.textContent = `‚úÖ ${file.name} loaded!`;
                    label.style.background = '#d4edda';
                };
                reader.readAsDataURL(file);
            }
        }

        function setupGameNameInput() {
            document.getElementById('gameNameInput').addEventListener('input', (e) => {
                document.getElementById('gameTitle').textContent = e.target.value;
            });
        }
        
        function handleCsvUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => parseCSV(e.target.result);
                reader.readAsText(file);
            }
        }

        // --- MODIFICATION START ---
        /**
         * A more robust CSV row parser that handles commas inside quoted fields.
         * @param {string} row - A single line from a CSV file.
         * @returns {string[]} An array of column values.
         */
        function parseCsvRow(row) {
            const parts = [];
            let currentPart = '';
            let inQuotes = false;
            for (let i = 0; i < row.length; i++) {
                const char = row[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    parts.push(currentPart);
                    currentPart = '';
                } else {
                    currentPart += char;
                }
            }
            parts.push(currentPart);
            return parts;
        }

        function parseCSV(csv) {
            try {
                const lines = csv.split('\n').filter(line => line.trim() !== '');
                const questions = [];
                const groupSet = new Set();
                
                for (let i = 1; i < lines.length; i++) { // Start from 1 to skip header
                    if (!lines[i].trim()) continue; // Skip empty lines

                    // Use the new, robust parser instead of the simple split
                    const parts = parseCsvRow(lines[i]);

                    // We expect 8 columns: question, 4 options, answer, level, group
                    if (parts.length >= 8) {
                        const group = (parts[7] || 'general').trim().toLowerCase();
                        questions.push({
                            question: parts[0].trim(),
                            options: [parts[1].trim(), parts[2].trim(), parts[3].trim(), parts[4].trim()],
                            answer: parseInt(parts[5].trim()) - 1,
                            level: parts[6].trim().toLowerCase(),
                            group: group
                        });
                        groupSet.add(group);
                    } else {
                        console.warn(`Skipping malformed CSV row ${i + 1}:`, lines[i]);
                    }
                }

                if (questions.length > 0) {
                    gameState.masterQuestions = questions;
                    gameState.allQuestionGroups = Array.from(groupSet).sort();
                    gameState.csvUploaded = true;
                    const label = document.getElementById('csvLabel');
                    label.innerHTML = `‚úÖ ${questions.length} questions loaded!`;
                    label.style.background = '#d4edda';
                    label.style.borderColor = '#28a745';
                } else { throw new Error("CSV file is empty or has no valid question rows."); }
            } catch (error) {
                alert(`Error parsing CSV: ${error.message}`);
                const label = document.getElementById('csvLabel');
                label.innerHTML = `‚ùå Error loading file. Try again.`;
                label.style.background = '#f8d7da';
                label.style.borderColor = '#d9534f';
            }
        }
        // --- MODIFICATION END ---

        function handleSoundUpload(event, audioId) {
            const file = event.target.files[0];
            const audioEl = document.getElementById(audioId);
            const labelEl = document.getElementById(event.target.id + 'Label');
            if (file && audioEl && labelEl) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    audioEl.src = e.target.result;
                    gameState.soundsUploaded[audioId] = true;
                    labelEl.textContent = '‚úÖ Loaded';
                    labelEl.style.backgroundColor = '#d4edda';
                }
                reader.readAsDataURL(file);
            }
        }
        
        async function loadDefaultAssets() {
            if (!gameState.logoUploaded) {
                const imgSrc = DEFAULT_ASSETS.logo;
                const headerImg = document.getElementById('gameLogoImg');
                headerImg.src = imgSrc;
                headerImg.style.display = 'block';
                headerImg.parentElement.querySelector('span').style.display = 'none';
                const boardImg = document.getElementById('boardLogoImg');
                boardImg.src = imgSrc;
                boardImg.style.display = 'block';
                document.getElementById('logoLabel').textContent = `‚úÖ Default logo loaded!`;
            }

            if (!gameState.csvUploaded) {
                try {
                    const response = await fetch(DEFAULT_ASSETS.questions);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const csvText = await response.text();
                    parseCSV(csvText);
                    document.getElementById('csvLabel').innerHTML = `‚úÖ Default questions loaded!`;
                } catch (error) {
                    console.error('Could not load default questions.csv:', error);
                    alert('Could not load default questions.csv. Using built-in fallback questions.');
                    parseCSV(DEFAULT_QUESTIONS_RAW_CSV);
                }
            }

            for (const soundId in DEFAULT_ASSETS.sounds) {
                if (!gameState.soundsUploaded[soundId]) {
                    const audioEl = document.getElementById(soundId);
                    audioEl.src = DEFAULT_ASSETS.sounds[soundId];
                    const labelEl = document.getElementById(soundId + 'Label');
                    if (labelEl) {
                        labelEl.textContent = '‚úÖ Default';
                        labelEl.style.backgroundColor = '#e9ecef';
                    }
                }
            }
        }

        async function initializeAndPrepareGame() {
            initializeGameState();
            
            await loadDefaultAssets();
            
            const numPlayers = parseInt(document.getElementById('numPlayers').value);
            gameState.players = Array.from({ length: numPlayers }, (_, i) => ({
                name: document.getElementById(`player${i + 1}Name`).value || `Player ${i + 1}`,
                position: 0,
                stuckCounter: 0, 
                color: `player-${i + 1}`
            }));
            gameState.timerDuration = parseInt(document.getElementById('timerDuration').value);
            
            if (gameState.allQuestionGroups.length > 1) {
                populateAndShowGroupSelector();
            } else {
                gameState.selectedQuestionGroup = gameState.allQuestionGroups[0] || 'general';
                finalizeGameStart();
            }
        }

        function populateAndShowGroupSelector() {
            const container = document.getElementById('groupOptionsContainer');
            container.innerHTML = '';
            gameState.allQuestionGroups.forEach(group => {
                const btn = document.createElement('div');
                btn.className = 'group-option';
                btn.textContent = group;
                btn.onclick = () => selectGroup(group, btn);
                container.appendChild(btn);
            });
            document.getElementById('groupSelectionPopup').classList.add('active');
        }

        function selectGroup(groupName, element) {
            gameState.selectedQuestionGroup = groupName;
            document.querySelectorAll('.group-option').forEach(opt => opt.classList.remove('selected'));
            element.classList.add('selected');
            document.getElementById('finalizeStartBtn').disabled = false;
        }
        
        function finalizeGameStart() {
            if (!gameState.selectedQuestionGroup) {
                alert("Please select a question group to start.");
                return;
            }
            
            document.getElementById('groupSelectionPopup').classList.remove('active');
            
            gameState.availableQuestions = gameState.masterQuestions.filter(q => q.group === gameState.selectedQuestionGroup);

            if (gameState.availableQuestions.length === 0) {
                alert(`Error: No questions found for the selected group "${gameState.selectedQuestionGroup}". Please check your CSV file.`);
                resetGame();
                return;
            }
            
            gameState.gameStarted = true;
            document.getElementById('setupSection').classList.remove('active');
            document.getElementById('gameSection').classList.add('active');
            
            history = [];
            historyIndex = -1;
            saveStateToHistory(); 

            updateAllUI();
        }
        
        function startGame() {
            const popup = document.getElementById('guidelinePopup');
            const frame = document.getElementById('guidelineFrame');
            frame.src = 'assets/Game-Guidelines.pdf'; 
            popup.classList.add('active');
        }

        async function closeGuidelinesAndStart() {
            document.getElementById('guidelinePopup').classList.remove('active');
            await initializeAndPrepareGame();
        }
        
        function updatePlayersDisplay() {
            const list = document.getElementById('playersList');
            list.innerHTML = gameState.players.map(p => {
                const colors = { 'player-1':'#e74c3c', 'player-2':'#3498db', 'player-3':'#2ecc71', 'player-4':'#f1c40f', 'player-5':'#9b59b6', 'player-6':'#1abc9c'};
                const positionText = gameState.winners.find(w => w.name === p.name) ? 'Finished' : (p.position || 'Start');
                return `
                <div class="player-item">
                    <span style="display:inline-block;width:20px;height:20px;border-radius:50%;background-color:${colors[p.color]};margin-right:10px;"></span>
                    <span>${p.name}</span>
                    <span>Pos: ${positionText}</span>
                </div>`}).join('');
        }
        
        function updateCurrentPlayerDisplay() {
            if (gameState.players.length === 0 || isGameOver()) return;
            const player = gameState.players[gameState.currentPlayerIndex];
            const display = document.getElementById('currentPlayerDisplay');
            display.textContent = `${player.name}'s Turn`;
            const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f1c40f', '#9b59b6', '#1abc9c'];
            display.style.background = `linear-gradient(135deg, ${colors[gameState.currentPlayerIndex % colors.length]}, ${colors[(gameState.currentPlayerIndex + 1) % colors.length]})`;
        }

        function updateGameBoard() {
            document.querySelectorAll('.player').forEach(p => p.remove());
            gameState.players.forEach((player, index) => {
                if (player.position > 0 && !gameState.winners.find(w => w.name === player.name)) {
                    const cell = document.getElementById(`cell-${player.position}`);
                    if (cell) {
                        const playerEl = document.createElement('div');
                        playerEl.className = `player ${player.color}`;
                        playerEl.textContent = index + 1;
                        const existingPlayers = cell.querySelectorAll('.player').length;
                        playerEl.style.transform = `translate(${existingPlayers * 5}px, -${existingPlayers * 5}px)`;
                        cell.appendChild(playerEl);
                    }
                }
            });
        }

        function skipTurn() {
            if (isGameOver() || document.getElementById('rollButton').disabled) return;
            
            nextPlayer();
            updateAllUI();
            saveStateToHistory();
        }
        
        function rollDice() {
            if (!gameState.gameStarted || document.getElementById('rollButton').disabled) return;
            
            const dicePopup = document.getElementById('dicePopup');
            const dicePopupContent = document.getElementById('dicePopupContent');
            const sideBarDice = document.getElementById('dice');
            const rollButton = document.getElementById('rollButton');
            const skipTurnButton = document.getElementById('skipTurnButton');

            rollButton.disabled = true;
            skipTurnButton.disabled = true;

            dicePopup.classList.add('active');
            dicePopupContent.classList.add('rolling');
            playSound('diceRollSound');

            const player = gameState.players[gameState.currentPlayerIndex];
            let forcedRoll = 0;
            if (player.stuckCounter >= MAX_STUCK_TURNS && player.position > (BOARD_SIZE - 6)) {
                forcedRoll = BOARD_SIZE - player.position;
            }

            let rollCount = 0;
            const rollInterval = setInterval(() => {
                const randomFace = ['‚öÄ', '‚öÅ', '‚öÇ', '‚öÉ', '‚öÑ', '‚öÖ'][Math.floor(Math.random() * 6)];
                dicePopupContent.textContent = randomFace;
                sideBarDice.textContent = randomFace;

                if (++rollCount > 10) {
                    clearInterval(rollInterval);
                    const finalRoll = (forcedRoll > 0) ? forcedRoll : Math.floor(Math.random() * 6) + 1;
                    const finalFace = ['‚öÄ', '‚öÅ', '‚öÇ', '‚öÉ', '‚öÑ', '‚öÖ'][finalRoll - 1];
                    
                    dicePopupContent.textContent = finalFace;
                    sideBarDice.textContent = finalFace;
                    dicePopupContent.classList.remove('rolling');

                    setTimeout(() => {
                        dicePopup.classList.remove('active');
                        setTimeout(() => showQuestion(finalRoll), 300);
                    }, 1000);
                }
            }, 100);
        }
        
        function showQuestion(diceRoll) {
            if (gameState.availableQuestions.length === 0) {
                if (gameState.usedQuestions.length === 0) {
                    alert(`FATAL ERROR: No more questions available for group "${gameState.selectedQuestionGroup}". Game cannot continue.`);
                    forceEndGame();
                    return;
                }
                gameState.availableQuestions = [...gameState.usedQuestions];
                gameState.usedQuestions = [];
            }
            
            const level = diceRoll <= 2 ? 'easy' : (diceRoll <= 4 ? 'medium' : 'hard');
            let pool = gameState.availableQuestions.filter(q => q.level === level);
            if (pool.length === 0) pool = gameState.availableQuestions; 

            const questionIndexInPool = Math.floor(Math.random() * pool.length);
            const question = pool[questionIndexInPool];
            
            gameState.currentQuestion = question;
            gameState.selectedOption = -1;
            
            document.getElementById('questionPopup').dataset.diceRoll = diceRoll;
            document.getElementById('questionText').textContent = gameState.currentQuestion.question;
            const optionsContainer = document.getElementById('optionsContainer');
            optionsContainer.innerHTML = '';
            gameState.currentQuestion.options.forEach((opt, i) => {
                const optEl = document.createElement('div');
                optEl.className = 'option';
                optEl.textContent = `${i + 1}. ${opt}`;
                optEl.onclick = () => selectOption(i, optEl);
                optionsContainer.appendChild(optEl);
            });
            document.getElementById('questionPopup').classList.add('active');
            startQuestionTimer();
        }

        function startQuestionTimer() {
            let timeLeft = gameState.timerDuration;
            const timerEl = document.getElementById('questionTimer');
            timerEl.classList.remove('warning');
            clearInterval(gameState.questionTimer);
            gameState.questionTimer = setInterval(() => {
                timerEl.textContent = timeLeft;
                playSound('timerTickSound');
                if (timeLeft <= 5 && !timerEl.classList.contains('warning')) timerEl.classList.add('warning');
                if (--timeLeft < 0) {
                    clearInterval(gameState.questionTimer);
                    submitAnswer();
                }
            }, 1000);
        }

        function selectOption(index, el) {
            if (gameState.isSubmitting) return; 
            document.querySelectorAll('.option.selected').forEach(opt => opt.classList.remove('selected'));
            el.classList.add('selected');
            gameState.selectedOption = index;
        }

        function submitAnswer() {
            if (gameState.isSubmitting) return;
            gameState.isSubmitting = true;

            const timerTickAudio = document.getElementById('timerTickSound');
            if (timerTickAudio) {
                timerTickAudio.pause();
                timerTickAudio.currentTime = 0;
            }

            clearInterval(gameState.questionTimer);
            const isCorrect = gameState.selectedOption === gameState.currentQuestion.answer;
            const diceRoll = parseInt(document.getElementById('questionPopup').dataset.diceRoll, 10);
            
            const questionIndex = gameState.availableQuestions.findIndex(q => q.question === gameState.currentQuestion.question);
            if (questionIndex > -1) {
                const [usedQuestion] = gameState.availableQuestions.splice(questionIndex, 1);
                gameState.usedQuestions.push(usedQuestion);
            }

            document.querySelectorAll('.option').forEach((opt, i) => {
                if (i === gameState.currentQuestion.answer) opt.classList.add('correct');
                else if (i === gameState.selectedOption) opt.classList.add('wrong');
            });

            setTimeout(() => {
                document.getElementById('questionPopup').classList.remove('active');
                if (isCorrect) playSound('correctSound');
                else playSound('wrongSound');
                handleMove(diceRoll, isCorrect);
                gameState.isSubmitting = false; 
            }, 2000);
        }
        
        function finishTurn() {
            updateAllUI();
            if (isGameOver()) {
                 endGame();
            } else {
                nextPlayer();
                if (!isGameOver()) {
                    document.getElementById('rollButton').disabled = false;
                    document.getElementById('skipTurnButton').disabled = false;
                }
                saveStateToHistory();
            }
        }

        function handleMove(steps, isCorrect) {
            const player = gameState.players[gameState.currentPlayerIndex];
            const oldPosition = player.position;

            if (isCorrect) {
                const newPosition = oldPosition + steps;
                
                if (newPosition > BOARD_SIZE) {
                    player.stuckCounter++; 
                    finishTurn(); 
                    return;
                }

                player.position = newPosition;
                player.stuckCounter = 0; 
                updateGameBoard();
                playSound('moveSound');

                setTimeout(() => {
                    if (LADDERS[player.position]) {
                        player.position = LADDERS[player.position];
                        playSound('ladderSound');
                    }

                    if (player.position === 100 && !gameState.winners.some(w => w.name === player.name)) {
                        gameState.winners.push(player);
                        playSound('winSound');
                    }
                    finishTurn();
                }, 600);

            } else {
                const potentialPosition = oldPosition + steps;
                
                if (SNAKES[potentialPosition] && potentialPosition <= BOARD_SIZE) {
                    player.position = potentialPosition;
                    updateGameBoard();
                    playSound('moveSound');
                    
                    setTimeout(() => {
                        player.position = SNAKES[potentialPosition];
                        playSound('snakeSound');
                        finishTurn();
                    }, 600);
                } else {
                    finishTurn();
                }
            }
        }
        
        function nextPlayer() {
            do {
                gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
            } while (gameState.winners.some(p => p.name === gameState.players[gameState.currentPlayerIndex].name) && !isGameOver());
            
            updateCurrentPlayerDisplay();
        }
        
        function endGame() {
            const list = document.getElementById('winnersList');
            const remainingPlayers = gameState.players
                .filter(p => !gameState.winners.some(w => w.name === p.name))
                .sort((a, b) => b.position - a.position);
            const finalRanking = [...gameState.winners, ...remainingPlayers];

            list.innerHTML = finalRanking.map((p, i) => {
                const rankText = ['ü•á', 'ü•à', 'ü•â'][i] || `${i + 1}.`;
                return `<div class="winner-item"><span>${rankText} ${p.name}</span></div>`;
            }).join('');
            
            document.getElementById('winnersSection').style.display = 'block';
            document.getElementById('rollButton').disabled = true;
            document.getElementById('skipTurnButton').disabled = true;
            document.getElementById('currentPlayerDisplay').textContent = "Game Over!";
            updateHeaderButtons();
            saveStateToHistory(); 
        }
        
        function forceEndGame() {
            if (!gameState.gameStarted || isGameOver()) return;
            if (confirm('Are you sure you want to end the game and declare winners now?')) {
                endGame();
            }
        }
        
        function resetGame() {
            if (gameState.gameStarted && !isGameOver()) {
                if (!confirm('Are you sure you want to end the current game and start a new one?')) {
                    return;
                }
            }
            
            initializeGameState();
            
            const headerImg = document.getElementById('gameLogoImg');
            headerImg.src = '';
            headerImg.style.display = 'none';
            headerImg.parentElement.querySelector('span').style.display = 'inline';
            const boardImg = document.getElementById('boardLogoImg');
            boardImg.src = '';
            boardImg.style.display = 'none';
            document.getElementById('logoUpload').value = "";
            document.getElementById('logoLabel').innerHTML = `üìÅ Click to upload Logo`;
            document.getElementById('logoLabel').style.background = '#ecf0f1';
            
            document.getElementById('gameSection').classList.remove('active');
            document.getElementById('setupSection').classList.add('active');
            document.getElementById('winnersSection').style.display = 'none';
            document.getElementById('dice').textContent = 'üé≤';
            document.getElementById('rollButton').disabled = false;
            document.getElementById('skipTurnButton').disabled = false;
            document.getElementById('svgLayer').innerHTML = '';
            
            const csvLabel = document.getElementById('csvLabel');
            csvLabel.innerHTML = `üìÅ Click to upload CSV<br><small>Format: q,o1,o2,o3,o4,ans,lvl,group</small>`;
            csvLabel.style.background = '#ecf0f1';
            csvLabel.style.borderColor = '#bdc3c7';
            document.getElementById('csvUpload').value = "";

            document.querySelectorAll('.sound-upload-label').forEach(label => {
                label.textContent = 'Select file...';
                label.style.backgroundColor = '#ecf0f1';
            });
            document.querySelectorAll('.sound-effects audio').forEach(audio => { audio.src = ''; });

            history = [];
            historyIndex = -1;
            updateHistoryButtons();
            updateHeaderButtons();
            createBoard();
        }
        
        function playSound(soundId) {
            if (gameState.soundEnabled) {
                const audio = document.getElementById(soundId);
                if (audio && audio.src) {
                    audio.volume = gameState.volume;
                    audio.currentTime = 0;
                    audio.play().catch(e => {});
                }
            }
        }
        
        function updateSoundVolume() {
            document.querySelectorAll('audio').forEach(audio => audio.volume = gameState.volume);
        }
        
        function toggleFullscreen() {
            const el = document.getElementById('gameContainer');
            if (!document.fullscreenElement) el.requestFullscreen().catch(err => console.error(err));
            else document.exitFullscreen();
        }
        
        document.addEventListener('fullscreenchange', () => {
            const btn = document.getElementById('headerFullscreenBtn');
            btn.textContent = document.fullscreenElement ? '‚õ∂ Exit Fullscreen' : '‚õ∂ Fullscreen';
        });

</script>
